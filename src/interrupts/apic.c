#include <cpuid.h>
#include <cpuspeed.h>
#include <interrupts/apic.h>
#include <power/acpi/acpi.h>
#include <msr.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>

// OH MY GODD THIS SUCKS

uint32_t apic_address;
uint32_t * multicpu_stack = (void *) 0x500;
int * cpus_booted = (void *) 0x504;
char * cpus_lock = (void *) 0x508;
uint32_t * cpu_entry = (void *) 0x50c;
uint32_t bootcode_address = 0x1000;
int apic_supported = 0;
int madt_broken = 0;
int cpus = 1;
int multicore_enabled = 1;
volatile int protected_lock = 1;

static int my_apic_id;

// couldnt get linker to accept 16 and 32 bit code at same time :shrug:
uint8_t core_bootup[256] = {
	0xfa, 0x31, 0xc0, 0x8e, 0xd8, 0xb8, 0x01, 0x00, 0xf0, 0x01, 0x06, 0x04,
	0x05, 0xa0, 0x08, 0x05, 0x84, 0xc0, 0x75, 0xf9, 0xeb, 0x6a, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x9a,
	0xcf, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x92, 0xcf, 0x00, 0xff, 0xff,
	0x00, 0x00, 0x00, 0xfa, 0xcf, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xf2,
	0xcf, 0x00, 0x27, 0x00, 0x16, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x0f, 0x01, 0x16, 0x3e,
	0x10, 0x0f, 0x20, 0xc0, 0x83, 0xc8, 0x01, 0x0f, 0x22, 0xc0, 0xea, 0xa0,
	0x10, 0x08, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
	0x90, 0x90, 0x90, 0x90, 0x66, 0xb8, 0x10, 0x00, 0x8e, 0xd8, 0x8e, 0xd0,
	0x8b, 0x25, 0x00, 0x05, 0x00, 0x00, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x0f,
	0xa2, 0xc1, 0xeb, 0x18, 0x89, 0xd8, 0xb9, 0xff, 0x02, 0x00, 0x00, 0x31,
	0xd2, 0x0f, 0xaf, 0xc1, 0x29, 0xc4, 0xa1, 0x0c, 0x05, 0x00, 0x00, 0xff,
	0xd0, 0xeb, 0xfe
};

static void apic_find_myself() {
	uint32_t eax, ebx, ecx, edx;
	cpuid(0x01, &eax, &ebx, &ecx, &edx);
	my_apic_id = ebx >> 24;
}

uint32_t apic_read_register(uint32_t offset) {
	return *((volatile uint32_t *) (apic_address + offset));
}

void apic_write_register(uint32_t offset, uint32_t data) {
	*((volatile uint32_t *) (apic_address + offset)) = data;
}

void apic_enable_apic() {
	apic_write_register(0x80, 0);
	apic_write_register(0xe0, 0xffffffff);
	apic_write_register(0xd0, 0x01000000);
	apic_write_register(0xf0, 0x1ff);
}


void cpu_c_entry() {}

void apic_boot_cpu(int i) {
	if (i == my_apic_id) {
		return;
	}
	apic_write_register(0x280, 0);
	apic_write_register(0x310, (apic_read_register(0x310) & 0x00ffffff) | (i << 24));
	apic_write_register(0x300, (apic_read_register(0x300) & 0xfff00000) | 0x00c500);
	while (apic_read_register(0x300) & (1 << 12)) {
		__asm__ __volatile__ ("pause" : : : "memory");
	}
	apic_write_register(0x310, (apic_read_register(0x310) & 0x00ffffff) | (i << 24));
	apic_write_register(0x300, (apic_read_register(0x300) & 0xfff00000) | 0x008500);
	while (apic_read_register(0x300) & (1 << 12)) {
		__asm__ __volatile__ ("pause" : : : "memory");
	}

	volatile int k = cpu_hz / 20;
	while (k--) {}

	for (int j = 0; j < 2; j++) {
		int save = *cpus_booted;
		apic_write_register(0x280, 0);
		apic_write_register(0x310, (apic_read_register(0x310) & 0x00ffffff) | (i << 24));
		apic_write_register(0x300, (apic_read_register(0x300) & 0xfff0f800) | 0x000600 | (bootcode_address >> 12));
		volatile int k = cpu_hz / 10000;
		while (k--) {}
		while (apic_read_register(0x300) & (1 << 12)) {
			__asm__ __volatile__ ("pause" : : : "memory");
		}
		if (save != *cpus_booted) {
			return;
		}
	}
}

void apic_boot_cpus() {
	memcpy((void *) bootcode_address, core_bootup, 256);

	if (!MADT) {
		return;
	}

	uint32_t address = ((uint32_t) MADT) + sizeof(MADT_t);
	uint32_t end = ((uint32_t) MADT)+ MADT->header.length;
	MADT_APIC_t * madt_apic;
	*cpus_lock = 1;
	*cpu_entry = (uint32_t) cpu_c_entry;
	while (address < end) {
		madt_apic = (void *) address;
		address += madt_apic->length;
		if (madt_apic->length == 0) {
			// MADT fucked up
			madt_broken = 1;
			return;
		}
		if (madt_apic->type != 0) {
			continue;
		}
		apic_boot_cpu(madt_apic->apicid);
		cpus++;
	}
	*multicpu_stack = (uint32_t) (malloc(cpus * 0x2ff) + (cpus * 0x2ff));
	*cpus_lock = 0;
}

void apic_init() {
	*cpus_booted = 1;
	
	uint32_t eax, ebx, ecx, edx; // does the cpu even have an apic??
	cpuid(0x01, &eax, &ebx, &ecx, &edx);
	edx = (edx >> 9) & 1;
	apic_supported = edx;
	if (!apic_supported) {
		return;
	}
	apic_address = cpu_read_msr(MSR_APIC_BASE) & 0xfffff000;

	apic_enable_apic();
	apic_find_myself();

	if (!multicore_enabled) {
		return;
	}

	apic_boot_cpus();
}
